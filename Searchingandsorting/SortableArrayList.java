package Searchingandsorting;import java.util.*;public class SortableArrayList{	final int MAX_SIZE = 100;	    protected int count;    protected double[] arr = new double[MAX_SIZE];        /**     * Initialize the list     */    public SortableArrayList()    {    	// Initialize to an empty list    	count = 0;	}    /**     * Adds the new element to the end of the list.     *      * @param d the element to be added to the list	 */    public void add(double d)    {    	if ( isFull() ) {    		throw new RuntimeException( "List is full!" );    	}    	    	// Check if it's a duplicate    	if ( linearSearch( d ) != -1 ) {    		throw new RuntimeException( "Duplicate values not allowed!" );    	}    	    	// Add to the end of the list    	arr[count] = d;    	    	count++;    }       /**     * Returns true if this list is empty and false otherwise.     *     * @return true if the list is empty, false otherwise     */    public boolean isEmpty()    {    	return ( count == 0 );    }    /**     * Returns the number of elements in this list.     *     * @return the number of elements in the list     */    public int size()    {    	return count;    }        /**     * Returns whether the array is full or not     * @return	true if the array is full, false if not.     */    public boolean isFull()    {    	return (count == MAX_SIZE );    }    /**     * Returns a string representation of this list.     *     * @return a string representation of the list         */    public String toString()    {    	String listString = "[";    	    	boolean first = true;    	for ( int i = 0; i < count; i++ ) {    		// Only add commas before the not-first item.    		if ( !first ) { listString += ", "; }    		else { first = false; }    		    		listString += arr[i];    	}    	    	listString += "]";    	return listString;    }        /**     * Searches the list from front to back searching for the targetElement.     * Returns the index of the first found value     * @param targetElement     * @return	true if the element is found, false otherwise.     */    public int linearSearch(double targetElement) {    	for ( int i = 0; i < count; i++ ) {    		if ( arr[i] == targetElement ) {    			return i;    		}    	}    	// Not found    	return -1;    }        /**     * Searches the list from front to back searching for the targetElement.     * Returns the index     * @param targetElement     * @return	true if the element is found, false otherwise.     */    public int binarySearch(double targetElement) {    	int left = 0;    	int right = count - 1;    	int mid;    	    	while (left <= right) {    		mid = (left + right) / 2;    		if (arr[mid] < targetElement)    			left = mid + 1;    		else if (arr[mid] > targetElement)    			right = mid - 1;    		else     			return mid;    		    	}    	return -1;    }	/**	 * Sorts the list so that all nodes are in order based on their element	 */	public void selectionSort() {		for (int i = 0; i < count; i++) {			int jMin = i;			for (int j = i + 1; j < count; j++) {				if (arr[jMin] > arr[j]) {					jMin = j;				}			}			if (jMin != i) {				int temp = (int) arr[i];				arr[i] = arr[jMin];				arr[jMin] = temp;			}		}	}	/**	 * Sorts the list so that all nodes are in order based on their element	 */	public void insertionSort() {		int i = 1;				while ( i < count) {			int j = i;						while(j > 0 && arr[j - 1] > arr[j]) {				double temp = arr[j];				arr[j] = arr[j - 1];				arr[j - 1] = temp;								j = j - 1;							}			i = i + 1;		}	}	/**	 * Sorts the list so that all nodes are in order based on their element	 */	public void bubbleSort() {		for (int i = 0; i < count; i++) {						for (int j = 0; j < count - 1; j++) {				if (arr[j] > arr[j + 1]) {					double temp = arr[j];					arr[j] = arr[j + 1];					arr[j + 1] = temp;				}			}		}	}}